export declare type ArgumentTypes<T> = T extends (...args: infer U) => infer R ? U : never;
export declare type ReplaceReturnType<T, TNewReturn> = (...a: ArgumentTypes<T>) => TNewReturn;
export declare type WithBoolReturn<T> = ReplaceReturnType<T, boolean>;
export declare type WithVoidReturn<T> = ReplaceReturnType<T, void>;
export interface SignalBinding {
    detach(): boolean;
    dispose(): void;
}
export declare class Signal<T extends Function = (() => void)> {
    private _head;
    private _tail;
    private _filter;
    handlers(): SignalBinding[];
    hasAny(): boolean;
    has(node: SignalBinding): boolean;
    dispatch(...args: ArgumentTypes<T>): boolean;
    add(fn: WithVoidReturn<T>, thisArg?: any): SignalBinding;
    once(fn: WithVoidReturn<T>, thisArg?: any): SignalBinding;
    detach(node_: SignalBinding): this;
    detachAll(): this;
    filter(filter: WithBoolReturn<T>): void;
    proxy(...signals: Signal<T>[]): this;
    private _addSignalBinding;
}
