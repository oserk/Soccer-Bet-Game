/*!
 * type-signals - v1.1.0
 * https://github.com/englercj/type-signals
 * Compiled Wed, 22 Apr 2020 17:58:58 UTC
 *
 * type-signals is licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license
 */
var SignalBindingImpl = (function () {
    function SignalBindingImpl(fn, once, thisArg) {
        if (once === void 0) { once = false; }
        this.next = null;
        this.prev = null;
        this.owner = null;
        this.fn = fn;
        this.once = once;
        this.thisArg = thisArg;
    }
    SignalBindingImpl.prototype.detach = function () {
        if (this.owner === null)
            return false;
        this.owner.detach(this);
        return true;
    };
    SignalBindingImpl.prototype.dispose = function () {
        this.detach();
    };
    return SignalBindingImpl;
}());
var Signal = (function () {
    function Signal() {
        this._head = null;
        this._tail = null;
        this._filter = null;
    }
    Signal.prototype.handlers = function () {
        var node = this._head;
        var handlers = [];
        while (node) {
            handlers.push(node);
            node = node.next;
        }
        return handlers;
    };
    Signal.prototype.hasAny = function () {
        return !!this._head;
    };
    Signal.prototype.has = function (node) {
        return node.owner === this;
    };
    Signal.prototype.dispatch = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var node = this._head;
        if (!node)
            return false;
        if (this._filter && !this._filter.apply(this, args))
            return false;
        while (node) {
            if (node.once)
                this.detach(node);
            node.fn.apply(node.thisArg, args);
            node = node.next;
        }
        return true;
    };
    Signal.prototype.add = function (fn, thisArg) {
        if (thisArg === void 0) { thisArg = null; }
        return this._addSignalBinding(new SignalBindingImpl(fn, false, thisArg));
    };
    Signal.prototype.once = function (fn, thisArg) {
        if (thisArg === void 0) { thisArg = null; }
        return this._addSignalBinding(new SignalBindingImpl(fn, true, thisArg));
    };
    Signal.prototype.detach = function (node_) {
        var node = node_;
        if (node.owner !== this)
            return this;
        if (node.prev)
            node.prev.next = node.next;
        if (node.next)
            node.next.prev = node.prev;
        if (node === this._head) {
            this._head = node.next;
            if (node.next === null) {
                this._tail = null;
            }
        }
        else if (node === this._tail) {
            this._tail = node.prev;
            if (this._tail)
                this._tail.next = null;
        }
        node.owner = null;
        return this;
    };
    Signal.prototype.detachAll = function () {
        var node = this._head;
        if (!node)
            return this;
        this._head = null;
        this._tail = null;
        while (node) {
            node.owner = null;
            node = node.next;
        }
        return this;
    };
    Signal.prototype.filter = function (filter) {
        this._filter = filter;
    };
    Signal.prototype.proxy = function () {
        var _this = this;
        var signals = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            signals[_i] = arguments[_i];
        }
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.dispatch.apply(_this, args);
        };
        for (var i = 0; i < signals.length; ++i) {
            signals[i].add(fn);
        }
        return this;
    };
    Signal.prototype._addSignalBinding = function (node_) {
        var node = node_;
        if (!this._head) {
            this._head = node;
            this._tail = node;
        }
        else {
            if (this._tail)
                this._tail.next = node;
            node.prev = this._tail;
            this._tail = node;
        }
        node.owner = this;
        return node;
    };
    return Signal;
}());

export { Signal };
//# sourceMappingURL=type-signals.esm.js.map
