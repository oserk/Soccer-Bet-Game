{"version":3,"file":"type-signals.min.js","sources":["../src/index.ts"],"sourcesContent":["/** Helper to deduce the argument types of a function. */\nexport type ArgumentTypes<T> = T extends (... args: infer U ) => infer R ? U : never;\n\n/** Helper to replace the return type of a function with a different value. */\nexport type ReplaceReturnType<T, TNewReturn> = (...a: ArgumentTypes<T>) => TNewReturn;\n\n/** Helper to replace the return type of a function with `boolean`. */\nexport type WithBoolReturn<T> = ReplaceReturnType<T, boolean>;\n\n/** Helper to replace the return type of a function with `void`. */\nexport type WithVoidReturn<T> = ReplaceReturnType<T, void>;\n\n/**\n * Interface representing a single binding to the signal.\n * This can be used to detach the handler function from the owning signal\n * so that it will no longer receive events.\n */\nexport interface SignalBinding\n{\n    /** Detaches this binding from the owning signal. */\n    detach(): boolean;\n\n    /** Detaches this binding from the owning signal. */\n    dispose(): void;\n}\n\nclass SignalBindingImpl<T extends Function> implements SignalBinding\n{\n    readonly fn: WithVoidReturn<T>;\n    readonly once: boolean;\n    readonly thisArg: any;\n\n    next: SignalBindingImpl<T> | null = null;\n    prev: SignalBindingImpl<T> | null = null;\n    owner: Signal<any> | null = null;\n\n    constructor(fn: WithVoidReturn<T>, once = false, thisArg: any)\n    {\n        this.fn = fn;\n        this.once = once;\n        this.thisArg = thisArg;\n    }\n\n    detach(): boolean\n    {\n        if (this.owner === null)\n            return false;\n\n        this.owner.detach(this);\n\n        return true;\n    }\n\n    dispose(): void\n    {\n        this.detach();\n    }\n}\n\n/**\n * A signal is a dispatcher that can bind functions (handlers) to dispatched events.\n */\nexport class Signal<T extends Function = (() => void)>\n{\n    private _head: SignalBindingImpl<T> | null = null;\n    private _tail: SignalBindingImpl<T> | null = null;\n\n    private _filter: WithBoolReturn<T> | null = null;\n\n    /**\n     * Gathers a list of all the handlers currently bound to this signal.\n     */\n    handlers(): SignalBinding[]\n    {\n        let node = this._head;\n\n        const handlers = [];\n        while (node)\n        {\n            handlers.push(node);\n            node = node.next;\n        }\n\n        return handlers;\n    }\n\n    /**\n     * Returns true if this signal has any bound handlers.\n     */\n    hasAny(): boolean\n    {\n        return !!this._head;\n    }\n\n    /**\n     * Returns true if the given binding is owned by this signal.\n     *\n     * @param node The binding to check.\n     */\n    has(node: SignalBinding): boolean\n    {\n        return (node as SignalBindingImpl<T>).owner === this;\n    }\n\n    /**\n     * Dispatch an event to all handlers.\n     * If a filter was set, only if it returns `true` will the event get dispatched.\n     *\n     * @param args The arguments to pass to the filter and handlers.\n     * @returns True if the event was dispatched, false otherwise.\n     */\n    dispatch(...args: ArgumentTypes<T>): boolean\n    {\n        let node = this._head;\n\n        if (!node)\n            return false;\n\n        if (this._filter && !this._filter(...args))\n            return false;\n\n        while (node)\n        {\n            if (node.once)\n                this.detach(node);\n\n            node.fn.apply(node.thisArg, args);\n            node = node.next;\n        }\n\n        return true;\n    }\n\n    /**\n     * Binds a new handler function to this signal that will be called for each dispatch.\n     *\n     * @param fn The handler function to bind.\n     * @param thisArg Optional `this` argument to use when calling this handler\n     */\n    add(fn: WithVoidReturn<T>, thisArg: any = null): SignalBinding\n    {\n        return this._addSignalBinding(new SignalBindingImpl(fn, false, thisArg));\n    }\n\n    /**\n     * Binds a new handler function to this signal that will only be called once on the next dispatch.\n     *\n     * @param fn The handler function to bind.\n     * @param thisArg Optional `this` argument to use when calling this handler.\n     */\n    once(fn: WithVoidReturn<T>, thisArg: any = null): SignalBinding\n    {\n        return this._addSignalBinding(new SignalBindingImpl(fn, true, thisArg));\n    }\n\n    /**\n     * Detaches a binding from this signal so that it is no longer called.\n     *\n     * @param node_ The binding to detach.\n     */\n    detach(node_: SignalBinding): this\n    {\n        const node = node_ as SignalBindingImpl<T>;\n\n        if (node.owner !== this)\n            return this;\n\n        if (node.prev)\n            node.prev.next = node.next;\n\n        if (node.next)\n            node.next.prev = node.prev;\n\n        if (node === this._head)\n        {\n            this._head = node.next;\n\n            if (node.next === null)\n            {\n                this._tail = null;\n            }\n        }\n        else if (node === this._tail)\n        {\n            this._tail = node.prev;\n\n            if (this._tail)\n                this._tail.next = null;\n        }\n\n        node.owner = null;\n\n        return this;\n    }\n\n    /**\n     * Detaches all bindings.\n     */\n    detachAll()\n    {\n        let node = this._head;\n\n        if (!node)\n            return this;\n\n        this._head = null;\n        this._tail = null;\n\n        while (node)\n        {\n            node.owner = null;\n            node = node.next;\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets the filter function to be called on each dispatch. This function takes the same\n     * parameters as a handler, but must return a boolean. Only when this function returns\n     * `true` will an event dispatch actually call bound handlers.\n     *\n     * @param filter The function to use as the filter.\n     */\n    filter(filter: WithBoolReturn<T>)\n    {\n        this._filter = filter;\n    }\n\n    /**\n     * Sets up a link between the passed signals and this one such that when the passed\n     * signal is dispatched, this signal is also dispatched.\n     *\n     * @param signals The signals to proxy.\n     */\n    proxy(...signals: Signal<T>[]): this\n    {\n        const fn = (...args: ArgumentTypes<T>) => this.dispatch(...args);\n\n        for (let i = 0; i < signals.length; ++i)\n        {\n            signals[i].add(fn);\n        }\n\n        return this;\n    }\n\n    private _addSignalBinding(node_: SignalBinding): SignalBinding\n    {\n        const node = node_ as SignalBindingImpl<T>;\n\n        if (!this._head)\n        {\n            this._head = node;\n            this._tail = node;\n        }\n        else\n        {\n            if (this._tail)\n                this._tail.next = node;\n\n            node.prev = this._tail;\n            this._tail = node;\n        }\n\n        node.owner = this;\n\n        return node;\n    }\n}\n"],"names":["fn","once","thisArg","this","SignalBindingImpl","owner","detach","Signal","node","_head","handlers","push","next","_i","args","_filter","apply","_addSignalBinding","node_","prev","_tail","filter","signals","_this","dispatch","i","length","add"],"mappings":";;;;;;;;mCA0BA,iBAUI,WAAYA,EAAuBC,EAAcC,gBAAdD,MAJnCE,UAAoC,KACpCA,UAAoC,KACpCA,WAA4B,KAIxBA,KAAKH,GAAKA,EACVG,KAAKF,KAAOA,EACZE,KAAKD,QAAUA,EAiBvB,OAdIE,mBAAA,WAEI,OAAmB,OAAfD,KAAKE,QAGTF,KAAKE,MAAMC,OAAOH,OAEX,IAGXC,oBAAA,WAEID,KAAKG,iCAOb,aAEYH,WAAqC,KACrCA,WAAqC,KAErCA,aAAoC,KA0MhD,OArMII,qBAAA,WAKI,IAHA,IAAIC,EAAOL,KAAKM,MAEVC,EAAW,GACVF,GAEHE,EAASC,KAAKH,GACdA,EAAOA,EAAKI,KAGhB,OAAOF,GAMXH,mBAAA,WAEI,QAASJ,KAAKM,OAQlBF,gBAAA,SAAIC,GAEA,OAAQA,EAA8BH,QAAUF,MAUpDI,qBAAA,eAAS,aAAAM,mBAAAA,IAAAC,kBAEL,IAAIN,EAAOL,KAAKM,MAEhB,IAAKD,EACD,OAAO,EAEX,GAAIL,KAAKY,UAAYZ,KAAKY,cAALZ,KAAgBW,GACjC,OAAO,EAEX,KAAON,GAECA,EAAKP,MACLE,KAAKG,OAAOE,GAEhBA,EAAKR,GAAGgB,MAAMR,EAAKN,QAASY,GAC5BN,EAAOA,EAAKI,KAGhB,OAAO,GASXL,gBAAA,SAAIP,EAAuBE,GAEvB,oBAFuBA,QAEhBC,KAAKc,kBAAkB,IAAIb,EAAkBJ,GAAI,EAAOE,KASnEK,iBAAA,SAAKP,EAAuBE,GAExB,oBAFwBA,QAEjBC,KAAKc,kBAAkB,IAAIb,EAAkBJ,GAAI,EAAME,KAQlEK,mBAAA,SAAOW,GAEH,IAAMV,EAAOU,EAEb,OAAIV,EAAKH,QAAUF,OAGfK,EAAKW,OACLX,EAAKW,KAAKP,KAAOJ,EAAKI,MAEtBJ,EAAKI,OACLJ,EAAKI,KAAKO,KAAOX,EAAKW,MAEtBX,IAASL,KAAKM,OAEdN,KAAKM,MAAQD,EAAKI,KAEA,OAAdJ,EAAKI,OAELT,KAAKiB,MAAQ,OAGZZ,IAASL,KAAKiB,QAEnBjB,KAAKiB,MAAQZ,EAAKW,KAEdhB,KAAKiB,QACLjB,KAAKiB,MAAMR,KAAO,OAG1BJ,EAAKH,MAAQ,MAzBFF,MAiCfI,sBAAA,WAEI,IAAIC,EAAOL,KAAKM,MAEhB,IAAKD,EACD,OAAOL,KAKX,IAHAA,KAAKM,MAAQ,KACbN,KAAKiB,MAAQ,KAENZ,GAEHA,EAAKH,MAAQ,KACbG,EAAOA,EAAKI,KAGhB,OAAOT,MAUXI,mBAAA,SAAOc,GAEHlB,KAAKY,QAAUM,GASnBd,kBAAA,eAAA,oBAAMM,mBAAAA,IAAAS,kBAIF,IAFA,IAAMtB,EAAK,eAAC,aAAAa,mBAAAA,IAAAC,kBAA8B,OAAAS,EAAKC,eAALD,EAAiBT,IAElDW,EAAI,EAAGA,EAAIH,EAAQI,SAAUD,EAElCH,EAAQG,GAAGE,IAAI3B,GAGnB,OAAOG,MAGHI,8BAAR,SAA0BW,GAEtB,IAAMV,EAAOU,EAkBb,OAhBKf,KAAKM,OAOFN,KAAKiB,QACLjB,KAAKiB,MAAMR,KAAOJ,GAEtBA,EAAKW,KAAOhB,KAAKiB,MACjBjB,KAAKiB,MAAQZ,IATbL,KAAKM,MAAQD,EACbL,KAAKiB,MAAQZ,GAWjBA,EAAKH,MAAQF,KAENK"}