{"version":3,"file":"graphics-extras.min.js","sources":["../src/drawChamferRect.ts","../src/drawFilletRect.ts","../src/drawRegularPolygon.ts","../src/drawRoundedPolygon.ts","../src/drawStar.ts","../src/drawTorus.ts","../src/index.ts"],"sourcesContent":["import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw Rectangle with chamfer corners. These are angled corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawChamferRect\n * @param this\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} chamfer - non-zero real number, size of corner cutout\n * @returns {PIXI.Graphics} Returns self.\n */\nexport function drawChamferRect(this: Graphics,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    chamfer: number): Graphics\n{\n    if (chamfer <= 0)\n    {\n        return this.drawRect(x, y, width, height);\n    }\n\n    const inset = Math.min(chamfer, Math.min(width, height) / 2);\n    const right = x + width;\n    const bottom = y + height;\n    const points = [\n        x + inset, y,\n        right - inset, y,\n        right, y + inset,\n        right, bottom - inset,\n        right - inset, bottom,\n        x + inset, bottom,\n        x, bottom - inset,\n        x, y + inset,\n    ];\n\n    // Remove overlapping points\n    for (let i = points.length - 1; i >= 2; i -= 2)\n    {\n        if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n        {\n            points.splice(i - 1, 2);\n        }\n    }\n\n    return this.drawPolygon(points);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw Rectangle with fillet corners. This is much like rounded rectangle\n * however it support negative numbers as well for the corner radius.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawFilletRect\n * @param this\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} fillet - accept negative or positive values\n * @returns {PIXI.Graphics} Returns self.\n */\nexport function drawFilletRect(this: Graphics,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    fillet: number): Graphics\n{\n    if (fillet === 0)\n    {\n        return this.drawRect(x, y, width, height);\n    }\n\n    const maxFillet = Math.min(width, height) / 2;\n    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n    const right = x + width;\n    const bottom = y + height;\n    const dir = inset < 0 ? -inset : 0;\n    const size = Math.abs(inset);\n\n    return this\n        .moveTo(x, y + size)\n        .arcTo(x + dir, y + dir, x + size, y, size)\n        .lineTo(right - size, y)\n        .arcTo(right - dir, y + dir, right, y + size, size)\n        .lineTo(right, bottom - size)\n        .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n        .lineTo(x + size, bottom)\n        .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n        .closePath();\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a regular polygon where all sides are the same length.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRegularPolygon\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} rotation - Starting rotation values in radians..\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawRegularPolygon(this: Graphics,\n    x: number,\n    y: number,\n    radius: number,\n    sides: number,\n    rotation = 0): Graphics\n{\n    sides = Math.max(sides | 0, 3);\n    const startAngle = (-1 * Math.PI / 2) + rotation;\n    const delta = (Math.PI * 2) / sides;\n    const polygon = [];\n\n    for (let i = 0; i < sides; i++)\n    {\n        const angle = (i * delta) + startAngle;\n\n        polygon.push(\n            x + (radius * Math.cos(angle)),\n            y + (radius * Math.sin(angle))\n        );\n    }\n\n    return this.drawPolygon(polygon);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a regular polygon with rounded corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawRoundedPolygon\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} corner - Corner size in pixels.\n * @param {number} rotation - Starting rotation values in radians..\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawRoundedPolygon(this: Graphics,\n    x: number,\n    y: number,\n    radius: number,\n    sides: number,\n    corner: number,\n    rotation = 0): Graphics\n{\n    sides = Math.max((sides | 0), 3);\n\n    if (corner <= 0)\n    {\n        return this.drawRegularPolygon(x, y, radius, sides, rotation);\n    }\n\n    const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n    corner = Math.min(corner, sideLength);\n\n    const startAngle = (-1 * Math.PI / 2) + rotation;\n    const delta = (Math.PI * 2) / sides;\n    const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n    for (let i = 0; i < sides; i++)\n    {\n        const angle = (i * delta) + startAngle;\n        const x0 = x + (radius * Math.cos(angle));\n        const y0 = y + (radius * Math.sin(angle));\n        const a1 = angle + (Math.PI) + internalAngle;\n        const a2 = angle - (Math.PI) - internalAngle;\n        const x1 = x0 + (corner * Math.cos(a1));\n        const y1 = y0 + (corner * Math.sin(a1));\n        const x3 = x0 + (corner * Math.cos(a2));\n        const y3 = y0 + (corner * Math.sin(a2));\n\n        if (i === 0)\n        {\n            this.moveTo(x1, y1);\n        }\n        else\n        {\n            this.lineTo(x1, y1);\n        }\n        this.quadraticCurveTo(x0, y0, x3, y3);\n    }\n\n    return this.closePath();\n}\n","import { PI_2, Polygon } from '@pixi/core';\n\nimport type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a star shape with an arbitrary number of points.\n * @ignore\n */\nclass Star extends Polygon\n{\n    /**\n     * @param x - Center X position of the star\n     * @param y - Center Y position of the star\n     * @param points - The number of points of the star, must be > 1\n     * @param radius - The outer radius of the star\n     * @param innerRadius - The inner radius between points, default half `radius`\n     * @param rotation - The rotation of the star in radians, where 0 is vertical\n     */\n    constructor(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        super(polygon);\n    }\n}\n\n/**\n * Draw a star shape with an arbitrary number of points.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawStar\n * @param this\n * @param x - Center X position of the star\n * @param y - Center Y position of the star\n * @param points - The number of points of the star, must be > 1\n * @param radius - The outer radius of the star\n * @param innerRadius - The inner radius between points, default half `radius`\n * @param rotation - The rotation of the star in radians, where 0 is vertical\n * @returns - This Graphics object. Good for chaining method calls\n */\nexport function drawStar(this: Graphics,\n    x: number,\n    y: number,\n    points: number,\n    radius: number,\n    innerRadius: number,\n    rotation = 0): Graphics\n{\n    return this.drawPolygon(new Star(x, y, points, radius, innerRadius, rotation) as Polygon);\n}\n","import type { Graphics } from '@pixi/graphics';\n\n/**\n * Draw a torus shape, like a donut. Can be used for something like a circle loader.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n * @method PIXI.Graphics#drawTorus\n * @param this\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} innerRadius - Inner circle radius\n * @param {number} outerRadius - Outer circle radius\n * @param {number} [startArc=0] - Where to begin sweep, in radians, 0.0 = to the right\n * @param {number} [endArc=Math.PI*2] - Where to end sweep, in radians\n * @returns {PIXI.Graphics} This Graphics object. Good for chaining method calls\n */\nexport function drawTorus(this: Graphics,\n    x: number,\n    y: number,\n    innerRadius: number,\n    outerRadius: number,\n    startArc = 0,\n    endArc: number = Math.PI * 2): Graphics\n{\n    if (Math.abs(endArc - startArc) >= Math.PI * 2)\n    {\n        return this\n            .drawCircle(x, y, outerRadius)\n            .beginHole()\n            .drawCircle(x, y, innerRadius)\n            .endHole();\n    }\n\n    this.finishPoly();\n    this\n        .arc(x, y, innerRadius, endArc, startArc, true)\n        .arc(x, y, outerRadius, startArc, endArc, false)\n        .finishPoly();\n\n    return this;\n}\n","/// <reference path=\"../global.d.ts\" />\nimport { Graphics } from '@pixi/graphics';\nimport { drawChamferRect } from './drawChamferRect';\nimport { drawFilletRect } from './drawFilletRect';\nimport { drawRegularPolygon } from './drawRegularPolygon';\nimport { drawRoundedPolygon } from './drawRoundedPolygon';\nimport { drawStar } from './drawStar';\nimport { drawTorus } from './drawTorus';\n\nexport interface IGraphicsExtras\n{\n    drawTorus: typeof drawTorus;\n    drawChamferRect: typeof drawChamferRect;\n    drawFilletRect: typeof drawFilletRect;\n    drawRegularPolygon: typeof drawRegularPolygon;\n    drawRoundedPolygon: typeof drawRoundedPolygon;\n    drawStar: typeof drawStar;\n}\n\n// Assign extras to Graphics\nObject.defineProperties(Graphics.prototype, {\n    drawTorus: { value: drawTorus },\n    drawChamferRect: { value: drawChamferRect },\n    drawFilletRect: { value: drawFilletRect },\n    drawRegularPolygon: { value: drawRegularPolygon },\n    drawRoundedPolygon: { value: drawRoundedPolygon },\n    drawStar: { value: drawStar },\n});\n"],"names":["g","i","r","l","o","a","e","t","d"],"mappings":";;;;;;;;;;IAgBI,SAAA,eAAA,CAAA,CAAA,CACA,EACA,CACA,CAAA,CAAA,CACA,EACJ,CACI,GAAI,GAAW,CAEX,CAAA,YAAY,QAAS,CAAA,CAAA,CAAG,EAAG,CAAO,CAAA,CAAM,EAG5C,MAAM,CAAA,CAAQ,KAAK,GAAI,CAAA,CAAA,CAAS,KAAK,GAAI,CAAA,CAAA,CAAO,CAAM,CAAI,CAAA,CAAC,EACrD,CAAQ,CAAA,CAAA,CAAI,EACZ,CAAS,CAAA,CAAA,CAAI,EACb,CAAS,CAAA,CACX,EAAI,CAAO,CAAA,CAAA,CACX,EAAQ,CAAO,CAAA,CAAA,CACf,EAAO,CAAI,CAAA,CAAA,CACX,EAAO,CAAS,CAAA,CAAA,CAChB,EAAQ,CAAO,CAAA,CAAA,CACf,EAAI,CAAO,CAAA,CAAA,CACX,EAAG,CAAS,CAAA,CAAA,CACZ,EAAG,CAAI,CAAA,CACX,EAGA,IAAS,IAAA,CAAA,CAAI,EAAO,MAAS,CAAA,CAAA,CAAG,GAAK,CAAG,CAAA,CAAA,EAAK,EAEzC,CAAI,CAAO,KAAO,CAAO,CAAA,CAAA,CAAI,IAAM,CAAO,CAAA,CAAA,CAAI,KAAO,CAAO,CAAA,CAAA,CAAI,IAE5D,CAAO,CAAA,MAAA,CAAO,EAAI,CAAG,CAAA,CAAC,EAI9B,OAAO,IAAA,CAAK,WAAY,CAAA,CAAM,CAClC;;IClCI,SAAA,cAAA,CAAA,CAAA,CACA,CACA,CAAA,CAAA,CACA,CACA,CAAA,CAAA,CACJ,CACI,GAAI,CAAW,GAAA,CAAA,CAEX,OAAO,IAAA,CAAK,QAAS,CAAA,CAAA,CAAG,EAAG,CAAO,CAAA,CAAM,CAG5C,CAAA,MAAkB,CAAA,CAAA,IAAA,CAAK,GAAI,CAAA,CAAA,CAAO,CAAM,CAAA,CAAI,CACtC,CAAA,CAAA,CAAQ,IAAK,CAAA,GAAA,CAAI,EAAW,IAAK,CAAA,GAAA,CAAI,CAAC,CAAA,CAAW,CAAM,CAAC,CACxD,CAAA,CAAA,CAAQ,CAAI,CAAA,CAAA,CACZ,CAAS,CAAA,CAAA,CAAI,CACb,CAAA,CAAA,CAAM,EAAQ,CAAI,CAAA,CAAC,CAAQ,CAAA,CAAA,CAC3B,CAAO,CAAA,IAAA,CAAK,GAAI,CAAA,CAAK,CAE3B,CAAA,OACK,IAAA,CAAA,MAAA,CAAO,CAAG,CAAA,CAAA,CAAI,CAAI,CAClB,CAAA,KAAA,CAAM,CAAI,CAAA,CAAA,CAAK,CAAI,CAAA,CAAA,CAAK,CAAI,CAAA,CAAA,CAAM,CAAG,CAAA,CAAI,CACzC,CAAA,MAAA,CAAO,CAAQ,CAAA,CAAA,CAAM,CAAC,CACtB,CAAA,KAAA,CAAM,CAAQ,CAAA,CAAA,CAAK,CAAI,CAAA,CAAA,CAAK,CAAO,CAAA,CAAA,CAAI,CAAM,CAAA,CAAI,CACjD,CAAA,MAAA,CAAO,CAAO,CAAA,CAAA,CAAS,CAAI,CAC3B,CAAA,KAAA,CAAM,CAAQ,CAAA,CAAA,CAAK,CAAS,CAAA,CAAA,CAAK,CAAI,CAAA,CAAA,CAAQ,CAAM,CAAA,CAAA,CAAQ,CAAI,CAAA,CAC/D,MAAO,CAAA,CAAA,CAAI,CAAM,CAAA,CAAM,CACvB,CAAA,KAAA,CAAM,CAAI,CAAA,CAAA,CAAK,CAAS,CAAA,CAAA,CAAK,CAAG,CAAA,CAAA,CAAS,CAAM,CAAA,CAAI,CACnD,CAAA,SAAA,EACT;;IC9BO,SAAA,kBAAA,CACH,CACA,CAAA,CAAA,CACA,CACA,CAAA,CAAA,CACA,CAAW,CAAA,CAAA,CACf,CACI,CAAA,CAAQ,IAAK,CAAA,GAAA,CAAI,CAAQ,CAAA,CAAA,CAAG,CAAC,CAAA,CAC7B,MAAM,CAAA,CAAc,CAAK,CAAA,CAAA,IAAA,CAAK,EAAK,CAAA,CAAA,CAAK,CAClC,CAAA,CAAA,CAAS,IAAK,CAAA,EAAA,CAAK,CAAK,CAAA,CAAA,CACxB,CAAU,CAAA,EAEhB,CAAA,IAAA,IAAa,CAAA,CAAA,CAAA,CAAG,CAAI,CAAA,CAAA,CAAO,CAC3B,EAAA,CAAA,CACI,MAAM,CAAA,CAAS,CAAI,CAAA,CAAA,CAAS,CAE5B,CAAA,CAAA,CAAQ,IACJ,CAAA,CAAA,CAAK,CAAS,CAAA,IAAA,CAAK,GAAI,CAAA,CAAK,CAC5B,CAAA,CAAA,CAAK,CAAS,CAAA,IAAA,CAAK,GAAI,CAAA,CAAK,CAChC,EACJ,CAEA,OAAY,IAAA,CAAA,WAAA,CAAY,CAAO,CACnC;;ICtBO,SAAA,kBAAA,CACH,CACA,CAAA,CAAA,CACA,CACA,CAAA,CAAA,CACA,EACA,CAAW,CAAA,CAAA,CACf,CAGI,GAFA,EAAQ,IAAK,CAAA,GAAA,CAAK,CAAQ,CAAA,CAAA,CAAI,CAAC,CAE3B,CAAA,CAAA,EAAU,CAEV,CAAA,OAAY,IAAA,CAAA,kBAAA,CAAmB,CAAG,CAAA,CAAA,CAAG,EAAQ,CAAO,CAAA,CAAQ,CAGhE,CAAA,QAAoB,CAAS,CAAA,IAAA,CAAK,GAAI,CAAA,IAAA,CAAK,GAAK,CAAK,CAAA,CAAK,IAE1D,CAAA,CAAA,CAAS,IAAK,CAAA,GAAA,CAAI,CAAQ,CAAA,CAAU,EAEpC,MAAM,CAAA,CAAc,CAAK,CAAA,CAAA,IAAA,CAAK,GAAK,CAAK,CAAA,CAAA,CAClC,CAAS,CAAA,IAAA,CAAK,GAAK,CAAK,CAAA,CAAA,CACxB,CAAkB,CAAA,CAAA,CAAA,CAAQ,GAAK,IAAK,CAAA,EAAA,CAAM,CAAQ,CAAA,CAAA,CAExD,QAAa,CAAA,CAAA,CAAA,CAAG,CAAI,CAAA,CAAA,CAAO,IAC3B,CACI,MAAe,CAAA,CAAA,CAAA,CAAI,EAAS,CACtB,CAAA,CAAA,CAAK,CAAK,CAAA,CAAA,CAAS,IAAK,CAAA,GAAA,CAAI,CAAK,CAAA,CACjC,EAAK,CAAK,CAAA,CAAA,CAAS,IAAK,CAAA,GAAA,CAAI,CAAK,CACjC,CAAA,CAAA,CAAK,CAAS,CAAA,IAAA,CAAK,GAAM,CACzB,CAAA,CAAA,CAAK,CAAS,CAAA,IAAA,CAAK,EAAM,CAAA,CAAA,CACzB,CAAK,CAAA,CAAA,CAAM,EAAS,IAAK,CAAA,GAAA,CAAI,CAAE,CAAA,CAC/B,EAAK,CAAM,CAAA,CAAA,CAAS,IAAK,CAAA,GAAA,CAAI,CAAE,CAC/B,CAAA,CAAA,CAAK,CAAM,CAAA,CAAA,CAAS,IAAK,CAAA,GAAA,CAAI,CAAE,CAAA,CAC/B,EAAK,CAAM,CAAA,CAAA,CAAS,IAAK,CAAA,GAAA,CAAI,CAAE,CAErC,CAAI,CAAM,GAAA,CAAA,CAEN,KAAK,MAAO,CAAA,CAAA,CAAI,CAAE,CAAA,CAIlB,KAAK,MAAO,CAAA,CAAA,CAAI,CAAE,CAAA,CAEtB,KAAK,gBAAiB,CAAA,CAAA,CAAI,CAAI,CAAA,CAAA,CAAI,CAAE,EACxC,CAEA,OAAO,IAAA,CAAK,WAChB;;ICvDA,MAAM,UACNA,YAAA,CASI,YAAY,CAAW,CAAA,CAAA,CAAW,EAAgB,CAAgB,CAAA,CAAA,CAAsB,EAAW,CACnG,CAAA,CACI,EAAc,CAAe,EAAA,CAAA,CAAS,EAEtC,MAAM,CAAA,CAAc,GAAK,IAAK,CAAA,EAAA,CAAK,EAAK,CAClC,CAAA,CAAA,CAAM,EAAS,CACf,CAAA,CAAA,CAAQC,UAAO,CACf,CAAA,CAAA,CAAU,EAEhB,CAAA,IAAA,MAAa,CAAG,CAAA,CAAA,CAAI,EAAK,CACzB,EAAA,CAAA,CACI,MAAU,CAAA,CAAA,CAAA,CAAI,EAAI,CAAc,CAAA,CAAA,CAC1B,EAAS,CAAI,CAAA,CAAA,CAAS,EAE5B,CAAQ,CAAA,IAAA,CACJ,EAAK,CAAI,CAAA,IAAA,CAAK,IAAI,CAAK,CAAA,CACvB,EAAK,CAAI,CAAA,IAAA,CAAK,IAAI,CAAK,CAC3B,EACJ,CAEA,KAAA,CAAM,CAAO,EACjB,CACJ,CAiBI,SAAA,QAAA,CAAA,CAAA,CACA,EACA,CACA,CAAA,CAAA,CACA,EACA,CAAW,CAAA,CAAA,CACf,CACI,OAAO,IAAA,CAAK,YAAY,IAAI,CAAA,CAAK,EAAG,CAAG,CAAA,CAAA,CAAQ,EAAQ,CAAa,CAAA,CAAQ,CAAY,CAC5F;;IChDI,SAAA,SAAA,CAAA,CAAA,CACA,CACA,CAAA,CAAA,CACA,CACA,CAAA,CAAA,CAAW,CACX,CAAA,CAAA,CAAiB,IAAK,CAAA,EAAA,CAAK,CAC/B,CAAA,CACI,OAAI,IAAA,CAAK,IAAI,CAAS,CAAA,CAAQ,CAAK,EAAA,IAAA,CAAK,EAAK,CAAA,CAAA,CAElC,IACF,CAAA,UAAA,CAAW,CAAG,CAAA,CAAA,CAAG,CAAW,CAAA,CAC5B,SAAU,EAAA,CACV,WAAW,CAAG,CAAA,CAAA,CAAG,CAAW,CAAA,CAC5B,OAAQ,EAAA,EAGZ,IAAA,CAAA,UAAA,EACL,CAAA,IAAA,CACK,GAAI,CAAA,CAAA,CAAG,CAAG,CAAA,CAAA,CAAa,CAAQ,CAAA,CAAA,CAAU,CAAI,CAAA,CAAA,CAC7C,GAAI,CAAA,CAAA,CAAG,CAAG,CAAA,CAAA,CAAa,CAAU,CAAA,CAAA,CAAQ,CAAK,CAAA,CAAA,CAC9C,UAAW,EAAA,CAET,IACX,CAAA;;ICpBA,OAAO,gBAAiB,CAAAC,iBAAA,CAAS,SAAW,CAAA,CACxC,UAAW,CAAE,KAAA,CAAOC,SAAU,CAC9B,CAAA,eAAA,CAAiB,CAAE,KAAO,CAAAC,eAAgB,CAC1C,CAAA,cAAA,CAAgB,CAAE,KAAO,CAAAC,cAAe,EACxC,kBAAoB,CAAA,CAAE,MAAOC,kBAAmB,CAAA,CAChD,mBAAoB,CAAE,KAAA,CAAOC,kBAAmB,CAChD,CAAA,QAAA,CAAU,CAAE,KAAO,CAAAC,QAAS,CAChC,CAAC,CAAA;;;;;;"}