import { Signal } from 'type-signals';
export declare type INext = (err?: Error) => void;
export declare type IWorker<T> = (item: T, next: INext) => void;
export declare type IItemCallback = (...args: any[]) => void;
export declare type OnDoneSignal = () => void;
export declare type OnSaturatedSignal = () => void;
export declare type OnUnsaturatedSignal = () => void;
export declare type OnEmptySignal = () => void;
export declare type OnDrainSignal = () => void;
export declare type OnErrorSignal<T> = (err: Error, data: T) => void;
interface ITask<T> {
    data: T;
    callback?: IItemCallback;
}
export declare class AsyncQueue<T> {
    readonly worker: IWorker<T>;
    concurrency: number;
    private workers;
    private buffer;
    private paused;
    private _started;
    private _tasks;
    readonly onSaturated: Signal<OnSaturatedSignal>;
    readonly onUnsaturated: Signal<OnUnsaturatedSignal>;
    readonly onEmpty: Signal<OnEmptySignal>;
    readonly onDrain: Signal<OnDrainSignal>;
    readonly onError: Signal<OnErrorSignal<T>>;
    constructor(worker: IWorker<T>, concurrency?: number);
    get started(): boolean;
    reset(): void;
    push(data: T, callback?: IItemCallback): void;
    unshift(data: T, callback?: IItemCallback): void;
    process(): void;
    length(): number;
    running(): number;
    idle(): boolean;
    pause(): void;
    resume(): void;
    getTask(index: number): ITask<T>;
    private _insert;
    private _next;
}
export {};
