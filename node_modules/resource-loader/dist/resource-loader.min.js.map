{"version":3,"file":"resource-loader.min.js","sources":["../node_modules/type-signals/dist/type-signals.esm.js","../src/resource_type.ts","../src/load_strategies/AbstractLoadStrategy.ts","../src/utilities.ts","../src/load_strategies/MediaElementLoadStrategy.ts","../src/load_strategies/XhrLoadStrategy.ts","../src/load_strategies/AudioLoadStrategy.ts","../src/load_strategies/ImageLoadStrategy.ts","../src/load_strategies/VideoLoadStrategy.ts","../node_modules/parse-uri/index.js","../src/async/AsyncQueue.ts","../src/Resource.ts","../src/async/eachSeries.ts","../src/Loader.ts","../src/bundle.ts"],"sourcesContent":["/*!\n * type-signals - v1.0.3\n * https://github.com/englercj/type-signals\n * Compiled Sun, 15 Sep 2019 20:21:49 UTC\n *\n * type-signals is licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license\n */\nvar SignalBinding = (function () {\r\n    function SignalBinding(fn, once, thisArg) {\r\n        if (once === void 0) { once = false; }\r\n        this.next = null;\r\n        this.prev = null;\r\n        this.owner = null;\r\n        this.fn = fn;\r\n        this.once = once;\r\n        this.thisArg = thisArg;\r\n    }\r\n    SignalBinding.prototype.detach = function () {\r\n        if (this.owner === null)\r\n            return false;\r\n        this.owner.detach(this);\r\n        return true;\r\n    };\r\n    SignalBinding.prototype.dispose = function () {\r\n        this.detach();\r\n    };\r\n    return SignalBinding;\r\n}());\r\nvar Signal = (function () {\r\n    function Signal() {\r\n        this._head = null;\r\n        this._tail = null;\r\n        this._filter = null;\r\n    }\r\n    Signal.prototype.handlers = function () {\r\n        var node = this._head;\r\n        var handlers = [];\r\n        while (node) {\r\n            handlers.push(node);\r\n            node = node.next;\r\n        }\r\n        return handlers;\r\n    };\r\n    Signal.prototype.hasAny = function () {\r\n        return !!this._head;\r\n    };\r\n    Signal.prototype.has = function (node) {\r\n        return node.owner === this;\r\n    };\r\n    Signal.prototype.dispatch = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var node = this._head;\r\n        if (!node)\r\n            return false;\r\n        if (this._filter && !this._filter.apply(this, args))\r\n            return false;\r\n        while (node) {\r\n            if (node.once)\r\n                this.detach(node);\r\n            node.fn.apply(node.thisArg, args);\r\n            node = node.next;\r\n        }\r\n        return true;\r\n    };\r\n    Signal.prototype.add = function (fn, thisArg) {\r\n        if (thisArg === void 0) { thisArg = null; }\r\n        return this._addMiniSignalBinding(new SignalBinding(fn, false, thisArg));\r\n    };\r\n    Signal.prototype.once = function (fn, thisArg) {\r\n        if (thisArg === void 0) { thisArg = null; }\r\n        return this._addMiniSignalBinding(new SignalBinding(fn, true, thisArg));\r\n    };\r\n    Signal.prototype.detach = function (node) {\r\n        if (node.owner !== this)\r\n            return this;\r\n        if (node.prev)\r\n            node.prev.next = node.next;\r\n        if (node.next)\r\n            node.next.prev = node.prev;\r\n        if (node === this._head) {\r\n            this._head = node.next;\r\n            if (node.next === null) {\r\n                this._tail = null;\r\n            }\r\n        }\r\n        else if (node === this._tail) {\r\n            this._tail = node.prev;\r\n            if (this._tail)\r\n                this._tail.next = null;\r\n        }\r\n        node.owner = null;\r\n        return this;\r\n    };\r\n    Signal.prototype.detachAll = function () {\r\n        var node = this._head;\r\n        if (!node)\r\n            return this;\r\n        this._head = null;\r\n        this._tail = null;\r\n        while (node) {\r\n            node.owner = null;\r\n            node = node.next;\r\n        }\r\n        return this;\r\n    };\r\n    Signal.prototype.filter = function (filter) {\r\n        this._filter = filter;\r\n    };\r\n    Signal.prototype.proxy = function () {\r\n        var _this = this;\r\n        var signals = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            signals[_i] = arguments[_i];\r\n        }\r\n        var fn = function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return _this.dispatch.apply(_this, args);\r\n        };\r\n        for (var i = 0; i < signals.length; ++i) {\r\n            signals[i].add(fn);\r\n        }\r\n        return this;\r\n    };\r\n    Signal.prototype._addMiniSignalBinding = function (node) {\r\n        if (!this._head) {\r\n            this._head = node;\r\n            this._tail = node;\r\n        }\r\n        else {\r\n            if (this._tail)\r\n                this._tail.next = node;\r\n            node.prev = this._tail;\r\n            this._tail = node;\r\n        }\r\n        node.owner = this;\r\n        return node;\r\n    };\r\n    return Signal;\r\n}());\n\nexport { Signal, SignalBinding };\n//# sourceMappingURL=type-signals.esm.js.map\n","/**\n * Describes the type of data the Resource holds.\n */\nexport enum ResourceType\n{\n    /** The resource data type is unknown. */\n    Unknown,\n    /** The resource data is an ArrayBuffer. */\n    Buffer,\n    /** The resource data is a Blob. */\n    Blob,\n    /** The resource data is a parsed JSON Object. */\n    Json,\n    /** The resource data is a Document or <div/> element representing parsed XML. */\n    Xml,\n    /** The resource data is an <img/> element. */\n    Image,\n    /** The resource data is an <audio/> element. */\n    Audio,\n    /** The resource data is an <video/> element. */\n    Video,\n    /** The resource data is a string. */\n    Text,\n}\n\nexport enum ResourceState\n{\n    NotStarted,\n    Loading,\n    Complete,\n}\n","import { Signal } from 'type-signals';\nimport { ResourceType } from '../resource_type';\n\nexport interface ILoadConfig\n{\n    // The url for this resource, relative to the baseUrl of this loader.\n    url: string;\n\n    // A base url to use for just this resource load. This can be passed in\n    // as the base url for a subresource if desired.\n    baseUrl?: string;\n\n    // String to use for crossOrigin properties on load elements.\n    crossOrigin?: string;\n\n    // The time to wait in milliseconds before considering the load a failure.\n    timeout?: number;\n}\n\n/**\n * @category Type Aliases\n */\nexport namespace AbstractLoadStrategy\n{\n    export type OnErrorSignal = (errMessage: string) => void;\n    export type OnCompleteSignal = (type: ResourceType, data: any) => void;\n    export type OnProgressSignal = (percent: number) => void;\n}\n\n/**\n * Base load strategy interface that all custom load strategies\n * are expected to inherit from and implement.\n * @preferred\n */\nexport abstract class AbstractLoadStrategy<C extends ILoadConfig = ILoadConfig>\n{\n    /**\n     * Dispatched when the resource fails to load.\n     */\n    readonly onError: Signal<AbstractLoadStrategy.OnErrorSignal> = new Signal<AbstractLoadStrategy.OnErrorSignal>();\n\n    /**\n     * Dispatched once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     */\n    readonly onComplete: Signal<AbstractLoadStrategy.OnCompleteSignal> = new Signal<AbstractLoadStrategy.OnCompleteSignal>();\n\n    /**\n     * Dispatched each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     */\n    readonly onProgress: Signal<AbstractLoadStrategy.OnProgressSignal> = new Signal<AbstractLoadStrategy.OnProgressSignal>();\n\n    constructor(readonly config: C)\n    { }\n\n    /**\n     * Load the resource described by `config`.\n     */\n    abstract load(): void;\n\n    /**\n     * Abort the loading of the resource.\n     */\n    abstract abort(): void;\n}\n\nexport type AbstractLoadStrategyCtor<C extends ILoadConfig = ILoadConfig> =\n    new (config: C) => AbstractLoadStrategy<C>;\n","export type Overwrite<T1, T2> = {\n    [P in Exclude<keyof T1, keyof T2>]: T1[P]\n} & T2;\n\n/**\n * Extracts the extension (sans '.') of the file being loaded by the resource.\n */\nexport function getExtension(url: string)\n{\n    const isDataUrl = url.indexOf('data:') === 0;\n    let ext = '';\n\n    if (isDataUrl)\n    {\n        const slashIndex = url.indexOf('/');\n\n        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    }\n    else\n    {\n        const queryStart = url.indexOf('?');\n        const hashStart = url.indexOf('#');\n        const index = Math.min(\n            queryStart > -1 ? queryStart : url.length,\n            hashStart > -1 ? hashStart : url.length\n        );\n\n        url = url.substring(0, index);\n        ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n\n    return ext.toLowerCase();\n}\n\nexport function assertNever(x: never): never\n{\n    throw new Error('Unexpected value. Should have been never.');\n}\n","import { AbstractLoadStrategy, ILoadConfig } from './AbstractLoadStrategy';\nimport { getExtension, assertNever } from '../utilities';\nimport { ResourceType } from '../resource_type';\n\nexport interface IMediaElementLoadConfig extends ILoadConfig\n{\n    sourceSet?: string[];\n    mimeTypes?: string[];\n    loadElement?: HTMLMediaElement;\n}\n\nexport abstract class MediaElementLoadStrategy extends AbstractLoadStrategy<IMediaElementLoadConfig>\n{\n    private _boundOnLoad = this._onLoad.bind(this);\n    private _boundOnError = this._onError.bind(this);\n    private _boundOnTimeout = this._onTimeout.bind(this);\n\n    private _element = this._createElement();\n    private _elementTimer = 0;\n\n    constructor(config: IMediaElementLoadConfig, readonly elementType: ('audio' | 'video'))\n    {\n        super(config);\n    }\n\n    load(): void\n    {\n        const config = this.config;\n\n        if (config.crossOrigin)\n            this._element.crossOrigin = config.crossOrigin;\n\n        const urls = config.sourceSet || [config.url];\n\n        // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n        if ((navigator as any).isCocoonJS)\n        {\n            this._element.src = urls[0];\n        }\n        else\n        {\n            for (let i = 0; i < urls.length; ++i)\n            {\n                const url = urls[i];\n                let mimeType = config.mimeTypes ? config.mimeTypes[i] : undefined;\n\n                if (!mimeType)\n                    mimeType = `${this.elementType}/${getExtension(url)}`;\n\n                const source = document.createElement('source');\n\n                source.src = url;\n                source.type = mimeType;\n\n                this._element.appendChild(source);\n            }\n        }\n\n        this._element.addEventListener('load', this._boundOnLoad, false);\n        this._element.addEventListener('canplaythrough', this._boundOnLoad, false);\n        this._element.addEventListener('error', this._boundOnError, false);\n\n        this._element.load();\n\n        if (config.timeout)\n            this._elementTimer = window.setTimeout(this._boundOnTimeout, config.timeout);\n    }\n\n    abort(): void\n    {\n        this._clearEvents();\n        while (this._element.firstChild)\n        {\n            this._element.removeChild(this._element.firstChild);\n        }\n        this._error(`${this.elementType} load aborted by the user.`);\n    }\n\n    private _createElement(): HTMLMediaElement\n    {\n        if (this.config.loadElement)\n            return this.config.loadElement;\n        else\n            return document.createElement(this.elementType);\n    }\n\n    private _clearEvents(): void\n    {\n        clearTimeout(this._elementTimer);\n\n        this._element.removeEventListener('load', this._boundOnLoad, false);\n        this._element.removeEventListener('canplaythrough', this._boundOnLoad, false);\n        this._element.removeEventListener('error', this._boundOnError, false);\n    }\n\n    private _error(errMessage: string): void\n    {\n        this._clearEvents();\n        this.onError.dispatch(errMessage);\n    }\n\n    private _complete(): void\n    {\n        this._clearEvents();\n\n        let resourceType = ResourceType.Unknown;\n\n        switch (this.elementType)\n        {\n            case 'audio': resourceType = ResourceType.Audio; break;\n            case 'video': resourceType = ResourceType.Video; break;\n            default: assertNever(this.elementType);\n        }\n\n        this.onComplete.dispatch(resourceType, this._element);\n    }\n\n    private _onLoad(): void\n    {\n        this._complete();\n    }\n\n    private _onError(): void\n    {\n        this._error(`${this.elementType} failed to load.`);\n    }\n\n    private _onTimeout(): void\n    {\n        this._error(`${this.elementType} load timed out.`);\n    }\n}\n","import { AbstractLoadStrategy, ILoadConfig } from './AbstractLoadStrategy';\nimport { getExtension, assertNever } from '../utilities';\nimport { ResourceType } from '../resource_type';\n\n// tests if CORS is supported in XHR, if not we need to use XDR\n// Mainly this is for IE9 support.\nconst useXdr = !!((window as any).XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\n\nconst enum HttpStatus\n{\n    None = 0,\n    Ok = 200,\n    Empty = 204,\n    IeEmptyBug = 1223,\n}\n\n/**\n * The XHR response types.\n */\nexport enum XhrResponseType\n{\n    /** string */\n    Default     = 'text',\n    /** ArrayBuffer */\n    Buffer      = 'arraybuffer',\n    /** Blob */\n    Blob        = 'blob',\n    /** Document */\n    Document    = 'document',\n    /** Object */\n    Json        = 'json',\n    /** String */\n    Text        = 'text',\n};\n\nexport interface IXhrLoadConfig extends ILoadConfig\n{\n    xhrType?: XhrResponseType;\n}\n\n/**\n * Quick helper to get string xhr type.\n */\nfunction reqType(xhr: XMLHttpRequest): string\n{\n    return xhr.toString().replace('object ', '');\n}\n\nexport class XhrLoadStrategy extends AbstractLoadStrategy<IXhrLoadConfig>\n{\n    static readonly ResponseType = XhrResponseType;\n\n    private _boundOnLoad = this._onLoad.bind(this);\n    private _boundOnAbort = this._onAbort.bind(this);\n    private _boundOnError = this._onError.bind(this);\n    private _boundOnTimeout = this._onTimeout.bind(this);\n    private _boundOnProgress = this._onProgress.bind(this);\n\n    private _xhr = this._createRequest();\n    private _xhrType = XhrResponseType.Default;\n\n    load(): void\n    {\n        const config = this.config;\n        const ext = getExtension(config.url);\n\n        if (typeof config.xhrType !== 'string')\n        {\n            config.xhrType = this._determineXhrType(ext);\n        }\n\n        const xhr = this._xhr;\n\n        this._xhrType = config.xhrType || XhrResponseType.Default;\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n\n        if (useXdr)\n        {\n            // XDR needs a timeout value or it breaks in IE9\n            xhr.timeout = config.timeout || 5000;\n\n            xhr.onload = this._boundOnLoad;\n            xhr.onerror = this._boundOnError;\n            xhr.ontimeout = this._boundOnTimeout;\n            xhr.onprogress = this._boundOnProgress;\n\n            xhr.open('GET', config.url, true);\n\n            // Note: The xdr.send() call is wrapped in a timeout to prevent an issue with\n            // the interface where some requests are lost if multiple XDomainRequests are\n            // being sent at the same time.\n            setTimeout(function () { xhr.send(); }, 0);\n        }\n        else\n        {\n            xhr.open('GET', config.url, true);\n\n            if (config.timeout)\n                xhr.timeout = config.timeout;\n\n            // load json as text and parse it ourselves. We do this because some browsers\n            // *cough* safari *cough* can't deal with it.\n            if (config.xhrType === XhrResponseType.Json || config.xhrType === XhrResponseType.Document)\n                xhr.responseType = XhrResponseType.Text;\n            else\n                xhr.responseType = config.xhrType;\n\n            xhr.addEventListener('load', this._boundOnLoad, false);\n            xhr.addEventListener('abort', this._boundOnAbort, false);\n            xhr.addEventListener('error', this._boundOnError, false);\n            xhr.addEventListener('timeout', this._boundOnTimeout, false);\n            xhr.addEventListener('progress', this._boundOnProgress, false);\n\n            xhr.send();\n        }\n    }\n\n    abort(): void\n    {\n        if (useXdr)\n        {\n            this._clearEvents();\n            this._xhr.abort();\n            this._onAbort();\n        }\n        else\n        {\n            // will call the abort event\n            this._xhr.abort();\n        }\n    }\n\n    private _createRequest(): XMLHttpRequest\n    {\n        if (useXdr)\n            return new (window as any).XDomainRequest();\n        else\n            return new XMLHttpRequest();\n    }\n\n    private _determineXhrType(ext: string): XhrResponseType\n    {\n        return XhrLoadStrategy._xhrTypeMap[ext] || XhrResponseType.Default;\n    }\n\n    private _clearEvents(): void\n    {\n        if (useXdr)\n        {\n            this._xhr.onload = null;\n            this._xhr.onerror = null;\n            this._xhr.ontimeout = null;\n            this._xhr.onprogress = null;\n        }\n        else\n        {\n            this._xhr.removeEventListener('load', this._boundOnLoad, false);\n            this._xhr.removeEventListener('abort', this._boundOnAbort, false);\n            this._xhr.removeEventListener('error', this._boundOnError, false);\n            this._xhr.removeEventListener('timeout', this._boundOnTimeout, false);\n            this._xhr.removeEventListener('progress', this._boundOnProgress, false);\n        }\n    }\n\n    private _error(errMessage: string): void\n    {\n        this._clearEvents();\n        this.onError.dispatch(errMessage);\n    }\n\n    private _complete(type: ResourceType, data: any): void\n    {\n        this._clearEvents();\n        this.onComplete.dispatch(type, data);\n    }\n\n    private _onLoad(): void\n    {\n        const xhr = this._xhr;\n        let text = '';\n\n        // XDR has no `.status`, assume 200.\n        let status = typeof xhr.status === 'undefined' ? HttpStatus.Ok : xhr.status;\n\n        // responseText is accessible only if responseType is '' or 'text' and on older browsers\n        if (typeof xhr.responseType === 'undefined' || xhr.responseType === '' || xhr.responseType === 'text')\n        {\n            text = xhr.responseText;\n        }\n\n        // status can be 0 when using the `file://` protocol so we also check if a response is set.\n        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n        if (status === HttpStatus.None && (text.length > 0 || xhr.responseType === XhrResponseType.Buffer))\n        {\n            status = HttpStatus.Ok;\n        }\n        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n        else if (status === HttpStatus.IeEmptyBug)\n        {\n            status = HttpStatus.Empty;\n        }\n\n        const flattenedStatus = Math.floor(status / 100) * 100;\n\n        if (flattenedStatus !== HttpStatus.Ok)\n        {\n            this._error(`[${xhr.status}] ${xhr.statusText}: ${xhr.responseURL}`);\n            return;\n        }\n\n        switch (this._xhrType)\n        {\n            case XhrResponseType.Buffer:\n                this._complete(ResourceType.Buffer, xhr.response);\n                break;\n\n            case XhrResponseType.Blob:\n                this._complete(ResourceType.Blob, xhr.response);\n                break;\n\n            case XhrResponseType.Document:\n                this._parseDocument(text);\n                break;\n\n            case XhrResponseType.Json:\n                this._parseJson(text);\n                break;\n\n            case XhrResponseType.Default:\n            case XhrResponseType.Text:\n                this._complete(ResourceType.Text, text);\n                break;\n\n            default:\n                assertNever(this._xhrType);\n        }\n    }\n\n    private _parseDocument(text: string): void\n    {\n        try\n        {\n            if (window.DOMParser)\n            {\n                const parser = new DOMParser();\n                const data = parser.parseFromString(text, 'text/xml');\n                this._complete(ResourceType.Xml, data);\n            }\n            else\n            {\n                const div = document.createElement('div');\n                div.innerHTML = text;\n                this._complete(ResourceType.Xml, div);\n            }\n        }\n        catch (e)\n        {\n            this._error(`Error trying to parse loaded xml: ${e}`);\n        }\n    }\n\n    private _parseJson(text: string): void\n    {\n        try\n        {\n            const data = JSON.parse(text);\n            this._complete(ResourceType.Json, data);\n        }\n        catch (e)\n        {\n            this._error(`Error trying to parse loaded json: ${e}`);\n        }\n    }\n\n    private _onAbort(): void\n    {\n        const xhr = this._xhr;\n        this._error(`${reqType(xhr)} Request was aborted by the user.`);\n    }\n\n    private _onError(): void\n    {\n        const xhr = this._xhr;\n        this._error(`${reqType(xhr)} Request failed. Status: ${xhr.status}, text: \"${xhr.statusText}\"`);\n    }\n\n    private _onTimeout(): void\n    {\n        const xhr = this._xhr;\n        this._error(`${reqType(xhr)} Request timed out.`);\n    }\n\n    private _onProgress(event: ProgressEvent): void\n    {\n        if (event && event.lengthComputable)\n        {\n            this.onProgress.dispatch(event.loaded / event.total);\n        }\n    }\n\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @param extname The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param xhrType The xhr type to set it to.\n     */\n    static setExtensionXhrType(extname: string, xhrType: XhrResponseType)\n    {\n        if (extname && extname.indexOf('.') === 0)\n            extname = extname.substring(1);\n\n        if (!extname)\n            return;\n\n        XhrLoadStrategy._xhrTypeMap[extname] = xhrType;\n    }\n\n    private static _xhrTypeMap: Partial<Record<string, XhrResponseType>> = {\n        // xml\n        xhtml:      XhrResponseType.Document,\n        html:       XhrResponseType.Document,\n        htm:        XhrResponseType.Document,\n        xml:        XhrResponseType.Document,\n        tmx:        XhrResponseType.Document,\n        svg:        XhrResponseType.Document,\n\n        // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n        // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n        // this should probably be fine.\n        tsx:        XhrResponseType.Document,\n\n        // images\n        gif:        XhrResponseType.Blob,\n        png:        XhrResponseType.Blob,\n        bmp:        XhrResponseType.Blob,\n        jpg:        XhrResponseType.Blob,\n        jpeg:       XhrResponseType.Blob,\n        tif:        XhrResponseType.Blob,\n        tiff:       XhrResponseType.Blob,\n        webp:       XhrResponseType.Blob,\n        tga:        XhrResponseType.Blob,\n\n        // json\n        json:       XhrResponseType.Json,\n\n        // text\n        text:       XhrResponseType.Text,\n        txt:        XhrResponseType.Text,\n\n        // fonts\n        ttf:        XhrResponseType.Buffer,\n        otf:        XhrResponseType.Buffer,\n    };\n}\n","import { MediaElementLoadStrategy, IMediaElementLoadConfig } from './MediaElementLoadStrategy';\n\nexport class AudioLoadStrategy extends MediaElementLoadStrategy\n{\n    constructor(config: IMediaElementLoadConfig)\n    {\n        super(config, 'audio');\n    }\n}\n","import { AbstractLoadStrategy, ILoadConfig } from './AbstractLoadStrategy';\nimport { ResourceType } from '../resource_type';\n\n// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nconst EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n\nexport interface IImageLoadConfig extends ILoadConfig\n{\n    loadElement?: HTMLImageElement;\n}\n\nexport class ImageLoadStrategy extends AbstractLoadStrategy<IImageLoadConfig>\n{\n    private _boundOnLoad = this._onLoad.bind(this);\n    private _boundOnError = this._onError.bind(this);\n    private _boundOnTimeout = this._onTimeout.bind(this);\n\n    private _element = this._createElement();\n    private _elementTimer = 0;\n\n    load(): void\n    {\n        const config = this.config;\n\n        if (config.crossOrigin)\n            this._element.crossOrigin = config.crossOrigin;\n\n        this._element.src = config.url;\n\n        this._element.addEventListener('load', this._boundOnLoad, false);\n        this._element.addEventListener('error', this._boundOnError, false);\n\n        if (config.timeout)\n            this._elementTimer = window.setTimeout(this._boundOnTimeout, config.timeout);\n    }\n\n    abort(): void\n    {\n        this._clearEvents();\n        this._element.src = EMPTY_GIF;\n        this._error('Image load aborted by the user.');\n    }\n\n    private _createElement(): HTMLImageElement\n    {\n        if (this.config.loadElement)\n            return this.config.loadElement;\n        else\n            return document.createElement('img')\n    }\n\n    private _clearEvents(): void\n    {\n        clearTimeout(this._elementTimer);\n\n        this._element.removeEventListener('load', this._boundOnLoad, false);\n        this._element.removeEventListener('error', this._boundOnError, false);\n    }\n\n    private _error(errMessage: string): void\n    {\n        this._clearEvents();\n        this.onError.dispatch(errMessage);\n    }\n\n    private _complete(): void\n    {\n        this._clearEvents();\n        this.onComplete.dispatch(ResourceType.Image, this._element);\n    }\n\n    private _onLoad(): void\n    {\n        this._complete();\n    }\n\n    private _onError(): void\n    {\n        this._error('Image failed to load.');\n    }\n\n    private _onTimeout(): void\n    {\n        this._error('Image load timed out.');\n    }\n}\n","import { MediaElementLoadStrategy, IMediaElementLoadConfig } from './MediaElementLoadStrategy';\n\nexport class VideoLoadStrategy extends MediaElementLoadStrategy\n{\n    constructor(config: IMediaElementLoadConfig)\n    {\n        super(config, 'video');\n    }\n}\n","'use strict'\n\nmodule.exports = function parseURI (str, opts) {\n  opts = opts || {}\n\n  var o = {\n    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],\n    q: {\n      name: 'queryKey',\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }\n\n  var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)\n  var uri = {}\n  var i = 14\n\n  while (i--) uri[o.key[i]] = m[i] || ''\n\n  uri[o.q.name] = {}\n  uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {\n    if ($1) uri[o.q.name][$1] = $2\n  })\n\n  return uri\n}\n","import { Signal } from 'type-signals';\n\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @typeparam R Return type of the function to wrap.\n * @param func The function to wrap.\n * @return The wrapping function.\n */\nfunction onlyOnce<R>(func: (...args: any[]) => R): (...args: any[]) => R\n{\n    let fn: typeof func | null = func;\n\n    return function onceWrapper(this: any, ...args: any[])\n    {\n        if (fn === null)\n            throw new Error('Callback was already called.');\n\n        const callFn = fn;\n        fn = null;\n        return callFn.apply(this, args);\n    };\n}\n\nexport type INext = (err?: Error) => void;\nexport type IWorker<T> = (item: T, next: INext) => void;\nexport type IItemCallback = (...args: any[]) => void;\n\nexport type OnDoneSignal = () => void;\nexport type OnSaturatedSignal = () => void;\nexport type OnUnsaturatedSignal = () => void;\nexport type OnEmptySignal = () => void;\nexport type OnDrainSignal = () => void;\nexport type OnErrorSignal<T> = (err: Error, data: T) => void;\n\ninterface ITask<T>\n{\n    data: T;\n    callback?: IItemCallback;\n}\n\n/**\n * Async queue.\n *\n * @typeparam T Element type of the queue.\n * @param worker The worker function to call for each task.\n * @param concurrency How many workers to run in parrallel. Must be greater than 0.\n * @return The async queue object.\n */\nexport class AsyncQueue<T>\n{\n    private workers = 0;\n    private buffer = 0;\n    private paused = false;\n\n    private _started = false;\n    private _tasks: ITask<T>[] = [];\n\n    readonly onSaturated: Signal<OnSaturatedSignal> = new Signal<OnSaturatedSignal>();\n    readonly onUnsaturated: Signal<OnUnsaturatedSignal> = new Signal<OnUnsaturatedSignal>();\n    readonly onEmpty: Signal<OnEmptySignal> = new Signal<OnEmptySignal>();\n    readonly onDrain: Signal<OnDrainSignal> = new Signal<OnDrainSignal>();\n    readonly onError: Signal<OnErrorSignal<T>> = new Signal<OnErrorSignal<T>>();\n\n    constructor(readonly worker: IWorker<T>, public concurrency = 1)\n    {\n        if (concurrency === 0)\n            throw new Error('Concurrency must not be zero');\n\n        this.buffer = concurrency / 4;\n    }\n\n    get started() { return this._started; }\n\n    reset()\n    {\n        this.onDrain.detachAll();\n        this.workers = 0;\n        this._started = false;\n        this._tasks = [];\n    }\n\n    push(data: T, callback?: IItemCallback)\n    {\n        this._insert(data, false, callback);\n    }\n\n    unshift(data: T, callback?: IItemCallback)\n    {\n        this._insert(data, true, callback);\n    }\n\n    process()\n    {\n        while (!this.paused && this.workers < this.concurrency && this._tasks.length)\n        {\n            const task = this._tasks.shift()!;\n\n            if (this._tasks.length === 0)\n                this.onEmpty.dispatch();\n\n            this.workers += 1;\n\n            if (this.workers === this.concurrency)\n                this.onSaturated.dispatch();\n\n            this.worker(task.data, onlyOnce(this._next(task)));\n        }\n    }\n\n    length()\n    {\n        return this._tasks.length;\n    }\n\n    running()\n    {\n        return this.workers;\n    }\n\n    idle()\n    {\n        return this._tasks.length + this.workers === 0;\n    }\n\n    pause()\n    {\n        if (this.paused === true)\n            return;\n\n        this.paused = true;\n    }\n\n    resume()\n    {\n        if (this.paused === false)\n            return;\n\n        this.paused = false;\n\n        // Need to call this.process once per concurrent\n        // worker to preserve full concurrency after pause\n        for (let w = 1; w <= this.concurrency; w++)\n        {\n            this.process();\n        }\n    }\n\n    getTask(index: number): ITask<T>\n    {\n        return this._tasks[index];\n    }\n\n    private _insert(data: T, insertAtFront: boolean, callback?: IItemCallback)\n    {\n        if (callback != null && typeof callback !== 'function')\n        {\n            throw new Error('task callback must be a function');\n        }\n\n        this._started = true;\n\n        if (data == null && this.idle())\n        {\n            // call drain immediately if there are no tasks\n            setTimeout(() => this.onDrain.dispatch(), 1);\n            return;\n        }\n\n        const task: ITask<T> = { data, callback };\n\n        if (insertAtFront)\n            this._tasks.unshift(task);\n        else\n            this._tasks.push(task);\n\n        setTimeout(() => this.process(), 1);\n    }\n\n    private _next(task: ITask<T>)\n    {\n        return (err?: Error, ...args: any[]) =>\n        {\n            this.workers -= 1;\n\n            if (task.callback)\n                task.callback(err, ...args);\n\n            if (err)\n                this.onError.dispatch(err, task.data);\n\n            if (this.workers <= (this.concurrency - this.buffer))\n                this.onUnsaturated.dispatch();\n\n            if (this.idle())\n                this.onDrain.dispatch();\n\n            this.process();\n        };\n    }\n}\n","import parseUri from 'parse-uri';\nimport { Signal, SignalBinding } from 'type-signals';\nimport { AbstractLoadStrategy, ILoadConfig, AbstractLoadStrategyCtor } from './load_strategies/AbstractLoadStrategy';\nimport { ImageLoadStrategy } from './load_strategies/ImageLoadStrategy';\nimport { AudioLoadStrategy } from './load_strategies/AudioLoadStrategy';\nimport { VideoLoadStrategy } from './load_strategies/VideoLoadStrategy';\nimport { XhrLoadStrategy } from './load_strategies/XhrLoadStrategy';\nimport { ResourceType, ResourceState } from './resource_type';\nimport { getExtension } from './utilities';\n\nexport interface IResourceOptions extends ILoadConfig\n{\n    // OVerride the load strategy to use for this one resource.\n    strategy?: AbstractLoadStrategy | AbstractLoadStrategyCtor;\n\n    // Extra info added by the user, usually for middleware.\n    metadata?: any;\n}\n\n/**\n * @category Type Aliases\n */\nexport namespace Resource\n{\n    export type OnStartSignal = (resource: Resource) => void;\n    export type OnErrorSignal = (resource: Resource) => void;\n    export type OnCompleteSignal = (resource: Resource) => void;\n    export type OnProgressSignal = (resource: Resource, percent: number) => void;\n}\n\n/**\n * Manages the state and loading of a resource and all child resources.\n * @preferred\n */\nexport class Resource\n{\n    private static _tempAnchor: HTMLAnchorElement | null = null;\n\n    private static _defaultLoadStrategy: AbstractLoadStrategyCtor = XhrLoadStrategy;\n    private static _loadStrategyMap: Partial<Record<string, AbstractLoadStrategyCtor>> = {\n        // images\n        gif:        ImageLoadStrategy,\n        png:        ImageLoadStrategy,\n        bmp:        ImageLoadStrategy,\n        jpg:        ImageLoadStrategy,\n        jpeg:       ImageLoadStrategy,\n        tif:        ImageLoadStrategy,\n        tiff:       ImageLoadStrategy,\n        webp:       ImageLoadStrategy,\n        tga:        ImageLoadStrategy,\n        svg:        ImageLoadStrategy,\n        'svg+xml':  ImageLoadStrategy, // for SVG data urls\n\n        // audio\n        mp3:        AudioLoadStrategy,\n        ogg:        AudioLoadStrategy,\n        wav:        AudioLoadStrategy,\n\n        // videos\n        mp4:        VideoLoadStrategy,\n        webm:       VideoLoadStrategy,\n        mov:        VideoLoadStrategy,\n    };\n\n    /**\n     * Sets the default load stragety to use when there is no extension-specific strategy.\n     */\n    static setDefaultLoadStrategy(strategy: AbstractLoadStrategyCtor): void\n    {\n        Resource._defaultLoadStrategy = strategy;\n    }\n\n    /**\n     * Sets the load strategy to be used for a specific extension.\n     *\n     * @param extname The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param strategy The load strategy to use for loading resources with that extension.\n     */\n    static setLoadStrategy(extname: string, strategy: AbstractLoadStrategyCtor): void\n    {\n        if (extname && extname.indexOf('.') === 0)\n            extname = extname.substring(1);\n\n        if (!extname)\n            return;\n\n        Resource._loadStrategyMap[extname] = strategy;\n    }\n\n    /**\n     * The name of this resource.\n     */\n    readonly name: string;\n\n    /**\n     * The child resources of this resource.\n     */\n    readonly children: Resource[] = [];\n\n    /**\n     * Dispatched when the resource beings to load.\n     */\n    readonly onStart: Signal<Resource.OnStartSignal> = new Signal<Resource.OnStartSignal>();\n\n    /**\n     * Dispatched each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     */\n    readonly onProgress: Signal<Resource.OnProgressSignal> = new Signal<Resource.OnProgressSignal>();\n\n    /**\n     * Dispatched once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     */\n    readonly onComplete: Signal<Resource.OnCompleteSignal> = new Signal<Resource.OnCompleteSignal>();\n\n    /**\n     * Dispatched after this resource has had all the *after* middleware run on it.\n     */\n    readonly onAfterMiddleware: Signal<Resource.OnCompleteSignal> = new Signal<Resource.OnCompleteSignal>();\n\n    /**\n     * The data that was loaded by the resource. The type of this member is\n     * described by the `type` member.\n     */\n    data: any = null;\n\n    /**\n     * Extra info added by the user, usually for middleware.\n     */\n    metadata: any;\n\n    /**\n     * Describes the type of the `data` member for this resource.\n     *\n     * @see ResourceType\n     */\n    type = ResourceType.Unknown;\n\n    /**\n     * The error that occurred while loading (if any).\n     */\n    error = '';\n\n    /**\n     * The progress chunk owned by this resource.\n     */\n    progressChunk = 0;\n\n    /**\n     * Storage for use privately by the Loader.\n     * Do not touch this member.\n     *\n     * @ignore\n     */\n    _dequeue: Function = function () {};\n\n    /**\n     * Storage for use privately by the Loader.\n     * Do not touch this member.\n     *\n     * @ignore\n     */\n    _onCompleteBinding: SignalBinding<Resource.OnCompleteSignal> | null = null;\n\n    private _strategy: AbstractLoadStrategy;\n    private _state = ResourceState.NotStarted;\n\n    /**\n     * @param name The name of the resource to load.\n     * @param options The options for the load strategy that will be used.\n     */\n    constructor(name: string, options: IResourceOptions)\n    {\n        this.name = name;\n        this.metadata = options.metadata;\n\n        if (typeof options.crossOrigin !== 'string')\n            options.crossOrigin = this._determineCrossOrigin(options.url);\n\n        if (options.strategy && typeof options.strategy !== 'function')\n        {\n            this._strategy = options.strategy;\n\n            // Only `Resource` is allowed to set the config object,\n            // it is otherwise readonly.\n            (this._strategy as any).config = options;\n        }\n        else\n        {\n            let StrategyCtor = options.strategy;\n\n            if (!StrategyCtor)\n                StrategyCtor = Resource._loadStrategyMap[getExtension(options.url)];\n\n            if (!StrategyCtor)\n                StrategyCtor = Resource._defaultLoadStrategy;\n\n            this._strategy = new StrategyCtor(options);\n        }\n\n        this._strategy.onError.add(this._error, this);\n        this._strategy.onComplete.add(this._complete, this);\n        this._strategy.onProgress.add(this._progress, this);\n    }\n\n    get strategy(): AbstractLoadStrategy { return this._strategy; }\n    get url(): string { return this._strategy.config.url; }\n    get isLoading(): boolean { return this._state === ResourceState.Loading; }\n    get isComplete(): boolean { return this._state === ResourceState.Complete; }\n\n    /**\n     * Aborts the loading of the resource.\n     */\n    abort(): void\n    {\n        this._strategy.abort();\n    }\n\n    /**\n     * Kicks off loading of this resource.\n     */\n    load(): void\n    {\n        this._state = ResourceState.Loading;\n        this.onStart.dispatch(this);\n        this._strategy.load();\n    }\n\n    private _error(errMessage: string): void\n    {\n        this._state = ResourceState.Complete;\n        this.error = errMessage;\n        this.onComplete.dispatch(this);\n    }\n\n    private _complete(type: ResourceType, data: any): void\n    {\n        this._state = ResourceState.Complete;\n        this.type = type;\n        this.data = data;\n        this.onComplete.dispatch(this);\n    }\n\n    private _progress(percent: number): void\n    {\n        this.onProgress.dispatch(this, percent);\n    }\n\n    /**\n     * Determines if a URL is crossOrigin, and if so returns the crossOrigin string.\n     */\n    private _determineCrossOrigin(url: string, loc = window.location): string\n    {\n        // data: and javascript: urls are considered same-origin\n        if (url.indexOf('data:') === 0 || url.indexOf('javascript:') === 0)\n            return '';\n\n        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n        // origin designed not to match window.location.origin, and will always require\n        // crossOrigin requests regardless of whether the location matches.\n        if (window.origin !== window.location.origin)\n            return 'anonymous';\n\n        if (!Resource._tempAnchor)\n            Resource._tempAnchor = document.createElement('a');\n\n        // Let the browser determine the full href for the url and then parse with the\n        // url lib. We can't use the properties of the anchor element because they\n        // don't work in IE9 :(\n        Resource._tempAnchor.href = url;\n\n        const parsed = parseUri(Resource._tempAnchor.href, { strictMode: true });\n\n        const samePort = (!parsed.port && loc.port === '') || (parsed.port === loc.port);\n        const protocol = parsed.protocol ? `${parsed.protocol}:` : '';\n\n        // if cross origin\n        if (parsed.host !== loc.hostname || !samePort || protocol !== loc.protocol)\n            return 'anonymous';\n\n        return '';\n    }\n}\n","/**\n * Iterates an array in series.\n *\n * @typeparam T Element type of the array.\n * @param array Array to iterate.\n * @param iterator Function to call for each element.\n * @param callback Function to call when done, or on error.\n * @param deferNext Break synchronous each loop by calling next with a setTimeout of 1.\n */\nexport function eachSeries<T>(\n    array: T[],\n    iterator: (item: T, next: (err?: Error) => void) => void,\n    callback?: (err?: Error) => void,\n    deferNext = false) : void\n{\n    let i = 0;\n    const len = array.length;\n\n    (function next(err?: Error)\n    {\n        if (err || i === len)\n        {\n            if (callback)\n                callback(err);\n            return;\n        }\n\n        if (deferNext)\n            setTimeout(() => iterator(array[i++], next), 1);\n        else\n            iterator(array[i++], next);\n    })();\n}\n","import parseUri from 'parse-uri';\nimport { Signal } from 'type-signals';\nimport { AsyncQueue } from './async/AsyncQueue';\nimport { Resource, IResourceOptions } from './Resource';\nimport { eachSeries } from './async/eachSeries';\n\n// some constants\nconst MAX_PROGRESS = 100;\nconst rgxExtractUrlHash = /(#[\\w-]+)?$/;\n\n/**\n * @category Type Aliases\n */\nexport namespace Loader\n{\n    export type ResourceMap = Partial<Record<string, Resource>>;\n\n    export type OnProgressSignal = (loader: Loader, resource: Resource) => void;\n    export type OnErrorSignal = (errMessage: string, loader: Loader, resource: Resource) => void;\n    export type OnLoadSignal = (loader: Loader, resource: Resource) => void;\n    export type OnStartSignal = (loader: Loader) => void;\n    export type OnCompleteSignal = (loader: Loader, resources: ResourceMap) => void;\n\n    export type MiddlewareFn = (resource: Resource, next: () => void) => void;\n    export type UrlResolverFn = (url: string, parsed: ReturnType<typeof parseUri>) => string;\n}\n\ninterface Middleware\n{\n    fn: Loader.MiddlewareFn;\n    priority: number;\n}\n\n/**\n * Options for a call to `.add()`.\n */\nexport interface IAddOptions extends IResourceOptions\n{\n    // Extra values to be used by specific load strategies.\n    [key: string]: any;\n\n    // The url to load the resource from.\n    url: string;\n\n    // A base url to use for just this resource load.\n    baseUrl?: string;\n\n    // The name of the resource to load, if not passed the url is used.\n    name?: string;\n\n    // Callback to add an an onComplete signal istener.\n    onComplete?: Resource.OnCompleteSignal;\n\n    // Parent resource this newly added resource is a child of.\n    parentResource?: Resource;\n}\n\n/**\n * Manages the state and loading of multiple resources to load.\n * @preferred\n */\nexport class Loader\n{\n    /**\n     * The default middleware priority (50).\n     */\n    static readonly DefaultMiddlewarePriority = 50;\n\n    /**\n     * The progress percent of the loader going through the queue.\n     */\n    progress = 0;\n\n    /**\n     * Loading state of the loader, true if it is currently loading resources.\n     */\n    loading = false;\n\n    /**\n     * A querystring to append to every URL added to the loader.\n     *\n     * This should be a valid query string *without* the question-mark (`?`). The loader will\n     * also *not* escape values for you. Make sure to escape your parameters with\n     * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n     *\n     * @example\n     * const loader = new Loader();\n     *\n     * loader.defaultQueryString = 'user=me&password=secret';\n     *\n     * // This will request 'image.png?user=me&password=secret'\n     * loader.add('image.png').load();\n     *\n     * loader.reset();\n     *\n     * // This will request 'image.png?v=1&user=me&password=secret'\n     * loader.add('iamge.png?v=1').load();\n     */\n    defaultQueryString = '';\n\n    /**\n     * All the resources for this loader keyed by name, or URL if no name was given.\n     */\n    resources: Loader.ResourceMap = {};\n\n    /**\n     * Dispatched once per errored resource.\n     */\n    readonly onError: Signal<Loader.OnErrorSignal> = new Signal<Loader.OnErrorSignal>();\n\n    /**\n     * Dispatched once per loaded resource.\n     */\n    readonly onLoad: Signal<Loader.OnLoadSignal> = new Signal<Loader.OnLoadSignal>();\n\n    /**\n     * Dispatched when the loader begins to process the queue.\n     */\n    readonly onStart: Signal<Loader.OnStartSignal> = new Signal<Loader.OnStartSignal>();\n\n    /**\n     * Dispatched when the queued resources all load.\n     */\n    readonly onComplete: Signal<Loader.OnCompleteSignal> = new Signal<Loader.OnCompleteSignal>();\n\n    /**\n     * Dispatched once per loaded or errored resource.\n     */\n    readonly onProgress: Signal<Loader.OnProgressSignal> = new Signal<Loader.OnProgressSignal>();\n\n    /**\n     * The base url for all resources loaded by this loader.\n     */\n    private _baseUrl = '';\n\n    /**\n     * The internal list of URL resolver functions called within `_prepareUrl`.\n     */\n    private _urlResolvers: Loader.UrlResolverFn[] = [];\n\n    /**\n     * The middleware to run after loading each resource.\n     */\n    private _middleware: Middleware[] = [];\n\n    /**\n     * The tracks the resources we are currently completing parsing for.\n     */\n    private _resourcesParsing: Resource[] = [];\n\n    /**\n     * The `_loadResource` function bound with this object context.\n     */\n    private _boundLoadResource = this._loadResource.bind(this);\n\n    /**\n     * The resources waiting to be loaded.\n     */\n    private _queue: AsyncQueue<Resource>;\n\n    /**\n     * @param baseUrl The base url for all resources loaded by this loader.\n     * @param concurrency The number of resources to load concurrently.\n     */\n    constructor(baseUrl = '', concurrency = 10)\n    {\n        this.baseUrl = baseUrl;\n\n        this._queue = new AsyncQueue<Resource>(this._boundLoadResource, concurrency);\n        this._queue.pause();\n\n        // Add default middleware. This is already sorted so no need to do that again.\n        this._middleware = Loader._defaultMiddleware.slice();\n    }\n\n    /**\n     * The base url for all resources loaded by this loader.\n     * Any trailing slashes are trimmed off.\n     */\n    get baseUrl(): string { return this._baseUrl; }\n\n    set baseUrl(url: string)\n    {\n        while (url.length && url.charAt(url.length - 1) === '/')\n        {\n            url = url.slice(0, -1);\n        }\n\n        this._baseUrl = url;\n    }\n\n    /**\n     * Adds a resource (or multiple resources) to the loader queue.\n     *\n     * This function can take a wide variety of different parameters. The only thing that is always\n     * required the url to load. All the following will work:\n     *\n     * ```js\n     * loader\n     *     // name & url param syntax\n     *     .add('http://...')\n     *     .add('key', 'http://...')\n     *\n     *     // object syntax\n     *     .add({\n     *         name: 'key3',\n     *         url: 'http://...',\n     *         onComplete: function () {},\n     *     })\n     *\n     *     // you can also pass an array of objects or urls or both\n     *     .add([\n     *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n     *         { url: 'http://...', onComplete: function () {} },\n     *         'http://...'\n     *     ])\n     * ```\n     */\n    add(url: string): this;\n    add(name: string, url: string): this;\n    add(options: IAddOptions): this;\n    add(resources: (IAddOptions|string)[]): this;\n    add(options: string | IAddOptions | (string | IAddOptions)[], url_?: string): this\n    {\n        // An array is a resource list.\n        if (Array.isArray(options))\n        {\n            for (let i = 0; i < options.length; ++i)\n            {\n                // can be string or IAddOptions, but either one is fine to pass\n                // as a param alone. The type assertion is just to appease TS.\n                this.add(options[i] as string);\n            }\n\n            return this;\n        }\n\n        let url = '';\n        let name = '';\n        let baseUrl = this._baseUrl;\n        let resOptions: IAddOptions = { url: '' };\n\n        if (typeof options === 'object')\n        {\n            url = options.url;\n            name = options.name || options.url;\n            baseUrl = options.baseUrl || baseUrl;\n            resOptions = options;\n        }\n        else\n        {\n            name = options;\n\n            if (typeof url_ === 'string')\n                url = url_;\n            else\n                url = name;\n        }\n\n        if (!url)\n            throw new Error('You must specify the `url` property.');\n\n        // if loading already you can only add resources that have a parent.\n        if (this.loading && !resOptions.parentResource)\n        {\n            throw new Error('Cannot add root resources while the loader is running.');\n        }\n\n        // check if resource already exists.\n        if (this.resources[name])\n        {\n            throw new Error(`Resource named \"${name}\" already exists.`);\n        }\n\n        // add base url if this isn't an absolute url\n        url = this._prepareUrl(url, baseUrl);\n        resOptions.url = url;\n\n        const resource = new Resource(name, resOptions);\n\n        this.resources[name] = resource;\n\n        if (typeof resOptions.onComplete === 'function')\n        {\n            resource.onAfterMiddleware.once(resOptions.onComplete);\n        }\n\n        // if actively loading, make sure to adjust progress chunks for that parent and its children\n        if (this.loading)\n        {\n            const parent = resOptions.parentResource!;\n            const incompleteChildren: Resource[] = [];\n\n            for (let i = 0; i < parent.children.length; ++i)\n            {\n                if (!parent.children[i].isComplete)\n                {\n                    incompleteChildren.push(parent.children[i]);\n                }\n            }\n\n            const fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n            const eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n            parent.children.push(resource);\n            parent.progressChunk = eachChunk;\n\n            for (let i = 0; i < incompleteChildren.length; ++i)\n            {\n                incompleteChildren[i].progressChunk = eachChunk;\n            }\n\n            resource.progressChunk = eachChunk;\n        }\n\n        // add the resource to the queue\n        this._queue.push(resource);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * You can optionally specify a priority for this middleware\n     * which will determine the order middleware functions are run.\n     * A lower priority value will make the function run earlier.\n     * That is, priority 30 is run before priority 50.\n     */\n    use(fn: Loader.MiddlewareFn, priority: number = Loader.DefaultMiddlewarePriority): this\n    {\n        this._middleware.push({ fn, priority });\n        this._middleware.sort((a, b) => a.priority - b.priority);\n        return this;\n    }\n\n    /**\n     * Resets the queue of the loader to prepare for a new load.\n     */\n    reset(): this\n    {\n        this.progress = 0;\n        this.loading = false;\n\n        this._queue.reset();\n        this._queue.pause();\n\n        // abort all resource loads\n        for (const k in this.resources)\n        {\n            const res = this.resources[k];\n\n            if (!res)\n                continue;\n\n            if (res._onCompleteBinding)\n                res._onCompleteBinding.detach();\n\n            if (res.isLoading)\n                res.abort();\n        }\n\n        this.resources = {};\n\n        return this;\n    }\n\n    /**\n     * Starts loading the queued resources.\n     */\n    load(cb?: Loader.OnCompleteSignal): this\n    {\n        if (typeof cb === 'function')\n            this.onComplete.once(cb);\n\n        // if the queue has already started we are done here\n        if (this.loading)\n            return this;\n\n        if (this._queue.idle())\n        {\n            this._onStart();\n            this._onComplete();\n        }\n        else\n        {\n            // distribute progress chunks\n            const numTasks = this._queue.length();\n            const chunk = MAX_PROGRESS / numTasks;\n\n            for (let i = 0; i < this._queue.length(); ++i)\n            {\n                this._queue.getTask(i).data.progressChunk = chunk;\n            }\n\n            // notify we are starting\n            this._onStart();\n\n            // start loading\n            this._queue.resume();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of resources to load concurrently.\n     */\n    get concurrency(): number\n    {\n        return this._queue.concurrency;\n    }\n\n    set concurrency(concurrency)\n    {\n        this._queue.concurrency = concurrency;\n    }\n\n    /**\n     * Add a function that can be used to modify the url just prior\n     * to `baseUrl` and `defaultQueryString` being applied.\n     */\n    addUrlResolver(func: Loader.UrlResolverFn): this\n    {\n        this._urlResolvers.push(func);\n        return this;\n    }\n\n    /**\n     * Prepares a url for usage based on the configuration of this object\n     */\n    private _prepareUrl(url: string, baseUrl: string): string\n    {\n        let parsed = parseUri(url, { strictMode: true });\n\n        this._urlResolvers.forEach(resolver => {\n            url = resolver(url, parsed);\n            parsed = parseUri(url, { strictMode: true });\n        });\n\n        // Only add `baseUrl` for urls that are not absolute.\n        if (!parsed.protocol && url.indexOf('//') !== 0)\n        {\n            // if the url doesn't start with a slash, then add one inbetween.\n            if (baseUrl.length && url.charAt(0) !== '/')\n                url = `${baseUrl}/${url}`;\n            else\n                url = baseUrl + url;\n        }\n\n        // if we need to add a default querystring, there is a bit more work\n        if (this.defaultQueryString)\n        {\n            const match = rgxExtractUrlHash.exec(url);\n\n            if (match)\n            {\n                const hash = match[0];\n\n                url = url.substr(0, url.length - hash.length);\n\n                if (url.indexOf('?') !== -1)\n                    url += `&${this.defaultQueryString}`;\n                else\n                    url += `?${this.defaultQueryString}`;\n\n                url += hash;\n            }\n        }\n\n        return url;\n    }\n\n    /**\n     * Loads a single resource.\n     */\n    private _loadResource(resource: Resource, dequeue: Function): void\n    {\n        resource._dequeue = dequeue;\n        resource._onCompleteBinding = resource.onComplete.once(this._onLoad, this);\n        resource.load();\n    }\n\n    /**\n     * Called once loading has started.\n     */\n    private _onStart(): void\n    {\n        this.progress = 0;\n        this.loading = true;\n        this.onStart.dispatch(this);\n    }\n\n    /**\n     * Called once each resource has loaded.\n     */\n    private _onComplete(): void\n    {\n        this.progress = MAX_PROGRESS;\n        this.loading = false;\n        this.onComplete.dispatch(this, this.resources);\n    }\n\n    /**\n     * Called each time a resources is loaded.\n     */\n    private _onLoad(resource: Resource): void\n    {\n        resource._onCompleteBinding = null;\n\n        // remove this resource from the async queue, and add it to our list\n        // of resources that are being parsed\n        this._resourcesParsing.push(resource);\n        resource._dequeue();\n\n        // run all the after middleware for this resource\n        eachSeries(\n            this._middleware,\n            (middleware, next) =>\n            {\n                middleware.fn.call(this, resource, next);\n            },\n            () =>\n            {\n                resource.onAfterMiddleware.dispatch(resource);\n\n                this.progress = Math.min(MAX_PROGRESS, this.progress + resource.progressChunk);\n                this.onProgress.dispatch(this, resource);\n\n                if (resource.error)\n                    this.onError.dispatch(resource.error, this, resource);\n                else\n                    this.onLoad.dispatch(this, resource);\n\n                this._resourcesParsing.splice(this._resourcesParsing.indexOf(resource), 1);\n\n                // do completion check\n                if (this._queue.idle() && this._resourcesParsing.length === 0)\n                    this._onComplete();\n            },\n            true);\n    }\n\n    /**\n     * A default array of middleware to run after loading each resource.\n     * Each of these middlewares are added to any new Loader instances when they are created.\n     */\n    private static _defaultMiddleware: Middleware[] = [];\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * You can optionally specify a priority for this middleware\n     * which will determine the order middleware functions are run.\n     * A lower priority value will make the function run earlier.\n     * That is, priority 30 is run before priority 50.\n     */\n    static use(fn: Loader.MiddlewareFn, priority = Loader.DefaultMiddlewarePriority): typeof Loader\n    {\n        Loader._defaultMiddleware.push({ fn, priority });\n        Loader._defaultMiddleware.sort((a, b) => a.priority - b.priority);\n        return Loader;\n    }\n}\n","import { AbstractLoadStrategy } from './load_strategies/AbstractLoadStrategy';\nimport { AudioLoadStrategy } from './load_strategies/AudioLoadStrategy';\nimport { ImageLoadStrategy } from './load_strategies/ImageLoadStrategy';\nimport { MediaElementLoadStrategy } from './load_strategies/MediaElementLoadStrategy';\nimport { VideoLoadStrategy } from './load_strategies/VideoLoadStrategy';\nimport { XhrLoadStrategy } from './load_strategies/XhrLoadStrategy';\n\nimport { Loader } from './Loader';\nimport { Resource } from './Resource';\nimport { ResourceType, ResourceState } from './resource_type';\n\n// TODO: Hide this stuff and only expose for tests\nimport { AsyncQueue } from './async/AsyncQueue';\nimport { eachSeries } from './async/eachSeries';\nimport { getExtension } from './utilities';\n\nObject.defineProperties(Loader, {\n    AbstractLoadStrategy: { get() { return AbstractLoadStrategy; } },\n    AudioLoadStrategy: { get() { return AudioLoadStrategy; } },\n    ImageLoadStrategy: { get() { return ImageLoadStrategy; } },\n    MediaElementLoadStrategy: { get() { return MediaElementLoadStrategy; } },\n    VideoLoadStrategy: { get() { return VideoLoadStrategy; } },\n    XhrLoadStrategy: { get() { return XhrLoadStrategy; } },\n\n    Resource: { get() { return Resource; } },\n    ResourceType: { get() { return ResourceType; } },\n    ResourceState: { get() { return ResourceState; } },\n\n    // TODO: Hide this stuff and only expose for tests\n    async: { get() { return { AsyncQueue, eachSeries }; } },\n    getExtension: { get() { return getExtension; } },\n});\n\nexport default Loader;\n"],"names":["ResourceType","ResourceState","SignalBinding","fn","once","thisArg","this","next","prev","owner","prototype","detach","dispose","Signal","_head","_tail","_filter","handlers","node","push","hasAny","has","dispatch","args","_i","arguments","length","apply","add","_addMiniSignalBinding","detachAll","filter","proxy","_this","signals","i","config","getExtension","url","ext","indexOf","slashIndex","substring","queryStart","hashStart","index","Math","min","lastIndexOf","toLowerCase","assertNever","x","Error","XhrResponseType","elementType","_super","_onLoad","bind","_onError","_onTimeout","_createElement","__extends","MediaElementLoadStrategy","crossOrigin","_element","urls","sourceSet","navigator","isCocoonJS","src","mimeType","mimeTypes","undefined","source","document","createElement","type","appendChild","addEventListener","_boundOnLoad","_boundOnError","load","timeout","_elementTimer","window","setTimeout","_boundOnTimeout","_clearEvents","firstChild","removeChild","_error","loadElement","clearTimeout","removeEventListener","errMessage","onError","resourceType","Unknown","Audio","Video","onComplete","_complete","AbstractLoadStrategy","ImageLoadStrategy","Image","useXdr","XDomainRequest","XMLHttpRequest","reqType","xhr","toString","replace","_onAbort","_onProgress","_createRequest","Default","XhrLoadStrategy","xhrType","_determineXhrType","_xhr","_xhrType","onload","onerror","ontimeout","onprogress","_boundOnProgress","open","send","Json","Document","responseType","Text","_boundOnAbort","abort","_xhrTypeMap","data","text","status","responseText","Buffer","floor","response","Blob","_parseDocument","_parseJson","statusText","responseURL","DOMParser","parseFromString","Xml","div","innerHTML","e","JSON","parse","event","lengthComputable","onProgress","loaded","total","extname","xhtml","html","htm","xml","tmx","svg","tsx","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","json","txt","ttf","otf","str","opts","o","key","q","name","parser","strict","loose","m","strictMode","exec","uri","$0","$1","$2","onlyOnce","func","callFn","worker","concurrency","buffer","Object","AsyncQueue","_started","onDrain","workers","_tasks","callback","_insert","paused","task","shift","onEmpty","onSaturated","_next","w","process","insertAtFront","idle","unshift","err","onUnsaturated","options","NotStarted","metadata","_determineCrossOrigin","strategy","_strategy","StrategyCtor","Resource","_loadStrategyMap","_defaultLoadStrategy","_progress","_state","Loading","Complete","onStart","error","percent","loc","location","origin","_tempAnchor","href","parsed","parseUri","samePort","port","protocol","host","hostname","svg+xml","mp3","AudioLoadStrategy","ogg","wav","mp4","VideoLoadStrategy","webm","mov","eachSeries","array","iterator","deferNext","len","rgxExtractUrlHash","baseUrl","_loadResource","_queue","_boundLoadResource","pause","_middleware","Loader","_defaultMiddleware","slice","_baseUrl","charAt","url_","Array","isArray","resOptions","loading","parentResource","resources","_prepareUrl","resource","onAfterMiddleware","parent_1","incompleteChildren","children","isComplete","eachChunk","progressChunk","priority","DefaultMiddlewarePriority","sort","a","b","k","progress","reset","res","_onCompleteBinding","isLoading","cb","_onStart","_onComplete","chunk","getTask","resume","_urlResolvers","forEach","resolver","defaultQueryString","match","hash","substr","dequeue","_dequeue","_resourcesParsing","middleware","call","onLoad","splice","defineProperties","get","async"],"mappings":"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"}