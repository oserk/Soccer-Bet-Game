import { Signal, SignalBinding } from 'type-signals';
import { AbstractLoadStrategy, ILoadConfig, AbstractLoadStrategyCtor } from './load_strategies/AbstractLoadStrategy';
import { ResourceType } from './resource_type';
export interface IResourceOptions extends ILoadConfig {
    strategy?: AbstractLoadStrategy | AbstractLoadStrategyCtor;
    metadata?: any;
}
export declare namespace Resource {
    type OnStartSignal = (resource: Resource) => void;
    type OnErrorSignal = (resource: Resource) => void;
    type OnCompleteSignal = (resource: Resource) => void;
    type OnProgressSignal = (resource: Resource, percent: number) => void;
}
export declare class Resource {
    private static _tempAnchor;
    private static _defaultLoadStrategy;
    private static _loadStrategyMap;
    static setDefaultLoadStrategy(strategy: AbstractLoadStrategyCtor): void;
    static setLoadStrategy(extname: string, strategy: AbstractLoadStrategyCtor): void;
    readonly name: string;
    readonly children: Resource[];
    readonly onStart: Signal<Resource.OnStartSignal>;
    readonly onProgress: Signal<Resource.OnProgressSignal>;
    readonly onComplete: Signal<Resource.OnCompleteSignal>;
    readonly onAfterMiddleware: Signal<Resource.OnCompleteSignal>;
    data: any;
    metadata: any;
    type: ResourceType;
    error: string;
    progressChunk: number;
    _dequeue: Function;
    _onCompleteBinding: SignalBinding<Resource.OnCompleteSignal> | null;
    private _strategy;
    private _state;
    constructor(name: string, options: IResourceOptions);
    get strategy(): AbstractLoadStrategy;
    get url(): string;
    get isLoading(): boolean;
    get isComplete(): boolean;
    abort(): void;
    load(): void;
    private _error;
    private _complete;
    private _progress;
    private _determineCrossOrigin;
}
